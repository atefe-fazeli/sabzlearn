{"ast":null,"code":"'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform {\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n    const readableHighWaterMark = this.readableHighWaterMark;\n    const timeWindow = internals.timeWindow;\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = maxRate / divider;\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    };\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n}\n\nexport default AxiosTransformStream;","map":{"version":3,"names":["stream","utils","kInternals","Symbol","AxiosTransformStream","Transform","constructor","options","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","readableHighWaterMark","internals","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","on","event","_read","size","_transform","chunk","encoding","callback","divider","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","emit","push","process","nextTick","transformChunk","chunkRemainder","maxChunkSize","bytesLeft","passed","setTimeout","subarray","transformNextChunk","err"],"sources":["D:/programming/projects/sabzlearn/frontend/node_modules/axios/lib/helpers/AxiosTransformStream.js"],"sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\nexport default AxiosTransformStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}